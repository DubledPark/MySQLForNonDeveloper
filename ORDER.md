###### 비개발자를 위한 MySQL
# 정렬

데이터를 가져올때는 보기 좋게 정렬할 필요가 있습니다. 지금부터 정렬에 대해서 알아봅시다.

## `ORDER BY`
우리는 `메뉴` 테이블에서 데이터를 가져오고 싶습니다.

```sql
SELECT * FROM menus;
```

만약 위 쿼리를 이용하여 데이터를 불러올 경우 다음과 같이 출력이 됩니다.

|id |이름  |가격 |
|---|------|-----|
|1  |김밥  |1500 |
|2  |동파육|10000|
|3  |라면  |4000 |
|4  |비빔밥|7000 |
|5  |한정식|50000|

지금까지 보지 못했던 컬럼이 보입니다! 바로 `id`라는 컬럼입니다. 각 테이블에는 `primary key`라는 것이 있습니다. `primary key`는 한국어로 **기본키**라고 부릅니다. 이렇게 말하면 조금 어려울텐데요, 데이터베이스에는 **고유 무결성**이라는 것이 지켜져야 합니다. 고유 무결성은 `테이블의 각 로우가 가지는 속성 값들이 서로 달라야 한다.`를 의미합니다. 한마디로 테이블 내에는 동일한 데이터가 있어서는 안된다는 뜻입니다. 다음과 같은 테이블은 고유 무결성을 위반한 경우입니다.

|이름|가격|
|----|----|
|김밥|1500|
|김밥|1500|
|라면|4000|
|라면|4000|

사실, 메뉴에 대해서는 조심만 한다면 고유 무결성이 깨질일은 없습니다. 똑같은 메뉴를 파는 가게는 없을테니까요. 하지만 `주문` 테이블은 다를 수 있습니다.

|이름  |주문메뉴|가격 |
|------|--------|-----|
|이선협|동파육  |10000|
|김지환|라면    |4000 |
|이선협|동파육  |10000|
|이선협|동파육  |10000|
|남세현|김밥    |1500 |

선협이는 동파육을 정말 좋아하는군요! 하지만 이렇게되면 주문 순서를 알 수 없습니다. 그래서 우리는 한가지 아이디어를 냈습니다.

|주문순서|이름  |주문메뉴|가격 |
|--------|------|--------|-----|
|1       |이선협|동파육  |10000|
|2       |김지환|라면    |4000 |
|3       |이선협|동파육  |10000|
|4       |이선협|동파육  |10000|
|5       |남세현|김밥    |1500 |

우리는 주문 순서대로 번호를 붙이기로 했습니다. 이렇게하면 어떤 순서로 주문이 왔는지 알 수 있겠군요! 여기서 `주문순서`는 앞서 본 `id`와 같습니다. 왜 `id` 일까요? 그다지 복잡한 이유는 아닙니다. 예전부터 관례적으로 기본키는 identity의 앞 두글자를 딴 `id`로 이름붙였습니다. (물론 꼭 `id`가 아니어도 됩니다.) 다시 처음으로 돌아가봅시다.

|id |이름  |가격 |
|---|------|-----|
|1  |김밥  |1500 |
|2  |동파육|10000|
|3  |라면  |4000 |
|4  |비빔밥|7000 |
|5  |한정식|50000|

우리는 메뉴를 싼 가격 순으로 보고 싶습니다. 메뉴가 적을때는 한눈에 보이겠지만 만약 메뉴가 1000개가 넘어간다면 사람의 눈으로는 어떤 메뉴가 가장 싼지 알기 힘듭니다. 여기서 `ORDER BY`라는 것이 등장합니다.

```sql
SELECT * FROM menus ORDER BY price;
```

위 쿼리를 간단하게 설명하자면 `'메뉴'의 데이터를 'price'를 기준으로 오름차순으로 정렬하자` 입니다. 사용법이 참 간단합니다. 여기서 유의해야할 점은 [순서](https://dev.mysql.com/doc/refman/5.5/en/select.html)입니다. `ORDER BY`의 순서는 꽤 뒤에 있습니다. 앞서 배운 `WHERE`와 섞어서 사용한다면 `ORDER BY`는 `WHERE`의 뒤에 있어야합니다.

```sql
SELECT * FROM menus WHERE price > 1500 ORDER BY price;
```

## 오름차순, 내림차순
앞에서 배운 `ORDER BY`는 오름차순을 기준으로 정렬했습니다. 만약 내림차순으로 정렬하고 싶다면 어떻게 해야할까요? `ORDER BY`에는 `ASC`와 `DESC`라는 **옵션**이 있습니다.

```sql
SELECT * FROM menus ORDER BY price; # 오름차순으로 정렬됩니다
SELECT * FROM menus ORDER BY price ASC; # 오름차순으로 정렬됩니다
SELECT * FROM menus ORDER BY price DESC; # 내림차순으로 정렬됩니다
```

첫 번째 쿼리는 앞서 배운 쿼리와 동일합니다. 두 번째 쿼리부터 모양이 조금 다릅니다. 추가된 것은 `ASC`와 `DESC`입니다. 추가된 옵션의 위치는 **컬럼의 뒤**에 위치해야 합니다. 오름차순으로 정렬할 때에는 `ASC`를 생략해도 되지만 내림차순으로 정렬할 경우에는 꼭 `DESC`를 컬럼의 뒤에 붙여줘야 합니다.

## 다수의 컬럼
두 컬럼에 대해서 정렬을 해야할 때가 있습니다. 예를들어 아까 예제로 사용한 테이블에서 먼저 가격순으로 정렬하고 그 다음으로 이름순으로 정렬할 수 있습니다. 메뉴 테이블에 다음과 같은 데이터가 있다고 가정해봅시다.

|id |이름          |가격 |
|---|--------------|-----|
|1  |김치라면      |5000 |
|2  |치즈라면      |6000 |
|3  |함께라면      |4000 |
|4  |바다가육지라면|4000 |
|5  |사노라면      |4000 |

라면만 가득한 메뉴군요. 만약 위 메뉴에서 싼 가격 순으로 정렬하고 가격이 같다면 '가나다'순으로 정렬하고 싶습니다. 이럴때는 다음과 같이 쿼리를 사용합니다.

```sql
SELECT * FROM menus ORDER BY price, name;
```

생각보다 어렵지 않습니다. 단지 뒤에 콤마(,)를 붙이고 컬럼 하나를 추가했을 뿐입니다. 다음과 같은 상황도 있을 수 있습니다. 가격은 비싼 순으로 정렬하고 가격이 같다면 '가나다'순으로 정렬하고 싶습니다. 이럴때는 앞서 배운 `ASC`와 `DESC`를 이용하면 됩니다.

```sql
SELECT * FROM menus ORDER BY price ASC, name DESC;
```

## 마치며
이번 장에서는 정렬에 대해서 배웠습니다. [다음 장](LIMIT.md)에서는 `LIMIT`를 배워봅시다. `LIMIT`는 아마 앞으로 배울 것 중에서 가장 쉬운 문법이 될겁니다.

## 지적, 수정사항에 대해서
Github 계정이 있으신 분들은 Issue에 지적사항을 등록해주시거나 직접 수정하여 Pull request를 주시면 반영하도록 하겠습니다. <br>Github 계정이 없으신 분들은 kciter@naver.com를 통해 지적사항을 보내주세요. :smile:

## 라이센스
<a rel="license" href="http://creativecommons.org/publicdomain/mark/1.0/">
<img src="https://licensebuttons.net/p/mark/1.0/88x31.png" alt="Public Domain Mark" />
</a>

이 문서는 [CC0 라이센스](LICENSE)를 따릅니다.

특허권 또는 상표권은 CC0에 의해 영향을 받지 않으며, 퍼블리시티권 및 프라이버시권 등 저작물 자체에 대해 또는 저작물 이용에 대해 타인이 갖는 권리 또한 영향을 받지 않습니다.

달리 정하지 않은 한, 본 저작물의 인증자는 관련법에서 허용하는 최대 한도 내에서 저작물에 대해 아무런 보증도 하지 않으며 저작물의 모든 이용에 관한 어떠한 책임도 지지 않습니다.

저작물을 사용하거나 인용할 때 저자나 인증자로부터 승인을 받았다는 뜻을 시사하여서는 안됩니다.
